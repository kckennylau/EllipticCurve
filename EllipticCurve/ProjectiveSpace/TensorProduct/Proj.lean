/-
Copyright (c) 2025 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau
-/

import EllipticCurve.ProjectiveSpace.TensorProduct.GradedAlgebra
import EllipticCurve.ProjectiveSpace.TensorProduct.ProjMap
import Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Basic
import Mathlib.AlgebraicGeometry.Pullbacks
import Mathlib.AlgebraicGeometry.PullbackCarrier
import Mathlib.LinearAlgebra.TensorProduct.Finiteness
import Mathlib.RingTheory.GradedAlgebra.Basic

/-! # Proj of Tensor Product

In this file we show `Proj (S ‚äó[R] ùíú) ‚âÖ Spec S √ó_R Proj ùíú` where `ùíú` is a graded `R`-algebra.
-/

universe u‚ÇÅ u‚ÇÇ u v

open TensorProduct in
def AlgHom.liftBaseChange {R S A B : Type*}
    [CommSemiring R] [CommSemiring S] [Semiring A] [Semiring B]
    [Algebra R S] [Algebra R A] [Algebra R B] [Algebra S B] [IsScalarTower R S B]
    (f : A ‚Üí‚Çê[R] B) :
    S ‚äó[R] A ‚Üí‚Çê[S] B :=
  .ofLinearMap (.liftBaseChange S f) (by simp [Algebra.TensorProduct.one_def]) fun x y ‚Ü¶ by
    induction x using TensorProduct.induction_on with
    | zero => simp
    | add x‚ÇÅ x‚ÇÇ hx‚ÇÅ hx‚ÇÇ => simp [add_mul, hx‚ÇÅ, hx‚ÇÇ]
    | tmul s‚ÇÅ a‚ÇÅ => induction y using TensorProduct.induction_on with
      | zero => simp
      | add y‚ÇÅ y‚ÇÇ hy‚ÇÅ hy‚ÇÇ => simp [mul_add, hy‚ÇÅ, hy‚ÇÇ]
      | tmul s‚ÇÇ a‚ÇÇ => simp [Algebra.TensorProduct.tmul_mul_tmul, mul_smul, smul_comm s‚ÇÅ]

@[simp] lemma AlgHom.liftBaseChange_tmul {R S A B : Type*}
    [CommSemiring R] [CommSemiring S] [Semiring A] [Semiring B]
    [Algebra R S] [Algebra R A] [Algebra R B] [Algebra S B] [IsScalarTower R S B]
    (f : A ‚Üí‚Çê[R] B) (s : S) (a : A) :
    f.liftBaseChange (s ‚äó‚Çú a) = s ‚Ä¢ f a := rfl

open TensorProduct in
@[ext high] theorem Algebra.TensorProduct.ext_ring {R S A B : Type*}
    [CommSemiring R] [Semiring A] [Algebra R A] [Semiring B] [Algebra R B]
    [CommSemiring S] [Algebra R S] [Algebra S B] [IsScalarTower R S B]
    {f g : S ‚äó[R] A ‚Üí‚Çê[S] B}
    (h : (AlgHom.restrictScalars R f).comp Algebra.TensorProduct.includeRight =
      (AlgHom.restrictScalars R g).comp Algebra.TensorProduct.includeRight) :
    f = g :=
  ext (Subsingleton.elim _ _) h

section degree

noncomputable def DirectSum.degree {Œπ M œÉ : Type*} [Zero M] [SetLike œÉ M] [ZeroMemClass œÉ M]
    [Zero Œπ] (‚Ñ≥ : Œπ ‚Üí œÉ) (x : M) : Œπ :=
  open Classical in if h : x ‚â† 0 ‚àß ‚àÉ i, x ‚àà ‚Ñ≥ i then h.2.choose else 0

namespace DirectSum

variable {Œπ M œÉ : Type*} [SetLike œÉ M] (‚Ñ≥ : Œπ ‚Üí œÉ)

theorem degree_of_mem [AddCommMonoid M] [DecidableEq Œπ] [Zero Œπ] [AddSubmonoidClass œÉ M]
    [Decomposition ‚Ñ≥] (x : M) (i : Œπ) (hx‚ÇÄ : x ‚â† 0) (hxi : x ‚àà ‚Ñ≥ i) : degree ‚Ñ≥ x = i := by
  rw [degree, dif_pos ‚ü®hx‚ÇÄ, _, hxi‚ü©]
  generalize_proofs h
  exact degree_eq_of_mem_mem _ h.choose_spec hxi hx‚ÇÄ

theorem mem_degree [AddCommMonoid M] [DecidableEq Œπ] [Zero Œπ] [AddSubmonoidClass œÉ M]
    [Decomposition ‚Ñ≥] (x : M) (hx : SetLike.IsHomogeneousElem ‚Ñ≥ x) : x ‚àà ‚Ñ≥ (degree ‚Ñ≥ x) := by
  by_cases hx‚ÇÄ : x = 0
  ¬∑ rw [hx‚ÇÄ]; exact zero_mem _
  obtain ‚ü®i, hxi‚ü© := hx
  rwa [degree_of_mem ‚Ñ≥ x i hx‚ÇÄ hxi]

theorem decompose_of_homogeneous [AddCommMonoid M] [DecidableEq Œπ] [Zero Œπ] [AddSubmonoidClass œÉ M]
    [Decomposition ‚Ñ≥] (x : M) (hx : SetLike.IsHomogeneousElem ‚Ñ≥ x) :
    decompose ‚Ñ≥ x = of (fun i ‚Ü¶ ‚Ñ≥ i) (degree ‚Ñ≥ x) (‚ü®x, mem_degree ‚Ñ≥ x hx‚ü© : ‚Ñ≥ _) :=
  decompose_of_mem ‚Ñ≥ _

theorem degree_mul [Semiring M] [AddSubmonoidClass œÉ M] [DecidableEq Œπ] [AddMonoid Œπ]
    [GradedRing ‚Ñ≥] (x y : M) (hx : SetLike.IsHomogeneousElem ‚Ñ≥ x)
    (hy : SetLike.IsHomogeneousElem ‚Ñ≥ y) (hxy : x * y ‚â† 0) :
    degree ‚Ñ≥ (x * y) = degree ‚Ñ≥ x + degree ‚Ñ≥ y :=
  degree_of_mem _ _ _ hxy <| SetLike.mul_mem_graded (mem_degree _ _ hx) (mem_degree _ _ hy)

theorem coe_apply_congr [AddCommMonoid M] [AddSubmonoidClass œÉ M]
    {x : ‚®Å i, ‚Ñ≥ i} {i j : Œπ} (h : i = j) : (x i : M) = x j := by
  subst h; rfl

end DirectSum

end degree

open DirectSum in
noncomputable def HomogeneousLocalization.proj‚ÇÄ {R A : Type*}
    [CommRing R] [CommRing A] [Algebra R A] {Œπ : Type*} [DecidableEq Œπ] [AddCancelCommMonoid Œπ]
    (ùíú : Œπ ‚Üí Submodule R A) [GradedAlgebra ùíú]
    (S : Submonoid A) (homog : S ‚â§ SetLike.homogeneousSubmonoid ùíú) :
    Localization S ‚Üí‚Çó[HomogeneousLocalization ùíú S] HomogeneousLocalization ùíú S where
  toFun x := x.liftOn (fun a s ‚Ü¶ .mk ‚ü®degree ùíú s.1, decompose ùíú a _,
    ‚ü®s, mem_degree _ _ (homog s.2)‚ü©, s.2‚ü©) fun {a‚ÇÅ a‚ÇÇ} {s‚ÇÅ s‚ÇÇ} h ‚Ü¶ by
      ext
      simp_rw [val_mk, Localization.mk_eq_mk_iff]
      rw [Localization.r_iff_exists] at h ‚ä¢
      obtain ‚ü®s, hs‚ü© := h
      refine ‚ü®s, ?_‚ü©
      have hs' := congr((decompose ùíú $hs (degree ùíú (s : A) +
        (degree ùíú (s‚ÇÅ : A) + degree ùíú (s‚ÇÇ : A))) : A))
      simp_rw [decompose_mul, decompose_of_homogeneous _ _ (homog s.2),
        decompose_of_homogeneous _ _ (homog s‚ÇÅ.2), decompose_of_homogeneous _ _ (homog s‚ÇÇ.2),
        coe_of_mul_apply_add, coe_apply_congr _ (add_comm (degree ùíú (s‚ÇÅ : A)) _),
        coe_of_mul_apply_add] at hs'
      exact hs'
  map_add' x y := Localization.induction_on‚ÇÇ x y fun c d ‚Ü¶ by
    ext
    by_cases hs‚ÇÄ : 0 ‚àà S
    ¬∑ subsingleton [IsLocalization.uniqueOfZeroMem hs‚ÇÄ]
    have ne_zero {x} (hx : x ‚àà S) : (x : A) ‚â† 0 := fun hx‚ÇÄ ‚Ü¶ hs‚ÇÄ <| hx‚ÇÄ ‚ñ∏ hx
    simp_rw [val_add, Localization.add_mk, Localization.liftOn_mk, val_mk,
      Localization.add_mk, decompose_add, add_apply, Submonoid.coe_mul, decompose_mul,
      Submodule.coe_add, Subtype.coe_eta]
    rw [degree_mul _ _ _ (homog c.2.2) (homog d.2.2) (ne_zero (c.2 * d.2).2),
      decompose_of_homogeneous _ _ (homog c.2.2),
      decompose_of_homogeneous _ _ (homog d.2.2),
      coe_of_mul_apply_add, coe_apply_congr _ (add_comm (degree ùíú (c.2 : A)) _),
      coe_of_mul_apply_add]
    rfl
  map_smul' r x := Localization.induction_on x fun d ‚Ü¶ by
    obtain ‚ü®c, rfl‚ü© := mk_surjective r
    ext
    by_cases hs‚ÇÄ : 0 ‚àà S
    ¬∑ subsingleton [IsLocalization.uniqueOfZeroMem hs‚ÇÄ]
    have ne_zero {x} (hx : x ‚àà S) : (x : A) ‚â† 0 := fun hx‚ÇÄ ‚Ü¶ hs‚ÇÄ <| hx‚ÇÄ ‚ñ∏ hx
    rw [RingHom.id_apply, Algebra.smul_def, smul_eq_mul, val_mul, algebraMap_apply, val_mk]
    simp_rw [Localization.mk_mul, Localization.liftOn_mk, val_mk, Localization.mk_mul,
      decompose_mul, decompose_coe, Subtype.coe_eta, Submonoid.coe_mul]
    rw [degree_mul _ _ _ ‚ü®_, c.den.2‚ü© (homog d.2.2) (ne_zero <| S.mul_mem c.den_mem d.2.2),
      degree_of_mem _ _ _ (ne_zero c.den_mem) c.den.2,
      coe_of_mul_apply_add]

theorem HomogeneousLocalization.proj‚ÇÄ_mk {R A : Type*}
    [CommRing R] [CommRing A] [Algebra R A] {Œπ : Type*} [DecidableEq Œπ] [AddCancelCommMonoid Œπ]
    (ùíú : Œπ ‚Üí Submodule R A) [GradedAlgebra ùíú]
    (S : Submonoid A) (homog : S ‚â§ SetLike.homogeneousSubmonoid ùíú)
    (a : A) (s : S) :
    HomogeneousLocalization.proj‚ÇÄ ùíú S homog (Localization.mk a s) =
    HomogeneousLocalization.mk ‚ü®DirectSum.degree ùíú (s : A), DirectSum.decompose ùíú a _,
      ‚ü®s, DirectSum.mem_degree _ _ (homog s.2)‚ü©, s.2‚ü© := rfl

@[simp] lemma HomogeneousLocalization.proj‚ÇÄ_val {R A : Type*}
    [CommRing R] [CommRing A] [Algebra R A] {Œπ : Type*} [DecidableEq Œπ] [AddCancelCommMonoid Œπ]
    (ùíú : Œπ ‚Üí Submodule R A) [GradedAlgebra ùíú]
    (S : Submonoid A) (homog : S ‚â§ SetLike.homogeneousSubmonoid ùíú)
    (x : HomogeneousLocalization ùíú S) :
    HomogeneousLocalization.proj‚ÇÄ ùíú S homog x.val = x := by
  ext
  by_cases hs‚ÇÄ : 0 ‚àà S
  ¬∑ subsingleton [IsLocalization.uniqueOfZeroMem hs‚ÇÄ]
  induction x using Quotient.inductionOn' with
  | h c =>
    simp_rw [val, Quotient.liftOn'_mk'', NumDenSameDeg.embedding, proj‚ÇÄ_mk, mk,
      Quotient.liftOn'_mk'', NumDenSameDeg.embedding]
    rw [DirectSum.decompose_of_mem _ c.num.2, DirectSum.coe_of_apply, if_pos]
    rw [DirectSum.degree_of_mem _ _ _ (mt (¬∑ ‚ñ∏ c.den_mem) hs‚ÇÄ) c.den.2]

noncomputable def HomogeneousLocalization.Away.proj‚ÇÄ {R A : Type*}
    [CommRing R] [CommRing A] [Algebra R A] {Œπ : Type*} [DecidableEq Œπ] [AddCancelCommMonoid Œπ]
    (ùíú : Œπ ‚Üí Submodule R A) [GradedAlgebra ùíú]
    {i : Œπ} {f : A} (hf : f ‚àà ùíú i) :
    Localization.Away (f : A) ‚Üí‚Çó[HomogeneousLocalization.Away ùíú f]
      HomogeneousLocalization.Away ùíú f :=
  HomogeneousLocalization.proj‚ÇÄ _ _ <| Submonoid.powers_le.mpr ‚ü®_, hf‚ü©

theorem HomogeneousLocalization.Away.proj‚ÇÄ_mk {R A : Type*}
    [CommRing R] [CommRing A] [Algebra R A] {Œπ : Type*} [DecidableEq Œπ] [AddCancelCommMonoid Œπ]
    (ùíú : Œπ ‚Üí Submodule R A) [GradedAlgebra ùíú]
    {i : Œπ} {f : A} (hf : f ‚àà ùíú i) (n : ‚Ñï) (a : A) (ha : a ‚àà ùíú (n ‚Ä¢ i)) :
    proj‚ÇÄ ùíú hf (.mk a ‚ü®f ^ n, n, rfl‚ü©) = .mk _ hf n a ha :=
  proj‚ÇÄ_val _ _ _ (Away.mk _ hf _ _ _)

theorem HomogeneousLocalization.Away.proj‚ÇÄ_mk' {R A : Type*}
    [CommRing R] [CommRing A] [Algebra R A] {Œπ : Type*} [DecidableEq Œπ] [AddCancelCommMonoid Œπ]
    (ùíú : Œπ ‚Üí Submodule R A) [GradedAlgebra ùíú]
    {i : Œπ} {f : A} (hf : f ‚àà ùíú i) (n : ‚Ñï) (a : ùíú (n ‚Ä¢ i)) :
    proj‚ÇÄ ùíú hf (.mk a ‚ü®f ^ n, n, rfl‚ü©) = .lof _ hf n a :=
  proj‚ÇÄ_mk _ _ _ _ _

open TensorProduct in
/-- `(S ‚äó[R] A)[(1 ‚äó‚Çú W)‚Åª¬π] ‚âÖ (S ‚äó[R] A)[W‚Åª¬π]`. -/
noncomputable def IsLocalization.tensorEquiv (R S A A‚ÇÅ SA‚ÇÅ : Type*)
    [CommSemiring R] [CommSemiring S] [CommSemiring A] [CommSemiring A‚ÇÅ] [CommSemiring SA‚ÇÅ]
    [Algebra R S] [Algebra R A] (W‚ÇÅ : Submonoid A) (W‚ÇÇ : Submonoid (S ‚äó[R] A))
    (hw : W‚ÇÅ.map Algebra.TensorProduct.includeRight = W‚ÇÇ)
    [Algebra A A‚ÇÅ] [IsLocalization W‚ÇÅ A‚ÇÅ]
    [Algebra R A‚ÇÅ] [IsScalarTower R A A‚ÇÅ]
    [Algebra (S ‚äó[R] A) SA‚ÇÅ] [IsLocalization W‚ÇÇ SA‚ÇÅ]
    [Algebra R SA‚ÇÅ] [Algebra S SA‚ÇÅ] [IsScalarTower R S SA‚ÇÅ] [IsScalarTower S (S ‚äó[R] A) SA‚ÇÅ]
    [IsScalarTower R (S ‚äó[R] A) SA‚ÇÅ] :
    SA‚ÇÅ ‚âÉ‚Çê[S] S ‚äó[R] A‚ÇÅ :=
  .ofAlgHom
  (IsLocalization.liftAlgHom
    (M := W‚ÇÇ)
    (f := Algebra.TensorProduct.map (1 : S ‚Üí‚Çê[S] S) (Algebra.algHom R A A‚ÇÅ)) <| by
      rw [‚Üê hw]
      rintro ‚ü®_, w, hw, rfl‚ü©
      exact (IsLocalization.map_units _ ‚ü®w, hw‚ü©).map Algebra.TensorProduct.includeRight)
  (AlgHom.liftBaseChange <| IsLocalization.liftAlgHom (M := W‚ÇÅ)
    (f := (Algebra.algHom _ _ _).comp (Algebra.TensorProduct.includeRight (R := R) (A := S)))
    fun w ‚Ü¶ IsLocalization.map_units (M := W‚ÇÇ) SA‚ÇÅ ‚ü®_, hw ‚ñ∏ ‚ü®_, w.2, rfl‚ü©‚ü©)
  (Algebra.TensorProduct.ext_ring <| IsLocalization.algHom_ext W‚ÇÅ <| by ext; simp [Algebra.algHom])
  (IsLocalization.algHom_ext W‚ÇÇ <| by ext; simp [Algebra.algHom])

open TensorProduct in
/-- `(S ‚äó[R] A)[(1 ‚äó‚Çú W)‚Åª¬π] ‚âÖ S ‚äó[R] A[W‚Åª¬π]`. -/
noncomputable def Localization.tensorEquiv (R S : Type*) {A : Type*}
    [CommSemiring R] [CommSemiring S] [CommSemiring A]
    [Algebra R S] [Algebra R A] (W : Submonoid A) :
    Localization (W.map (Algebra.TensorProduct.includeRight (R := R) (A := S))) ‚âÉ‚Çê[S]
    S ‚äó[R] Localization W :=
  IsLocalization.tensorEquiv R S A _ _ W _ rfl

open TensorProduct in
/-- `(S ‚äó[R] A)[(1 ‚äó‚Çú f)‚Åª¬π] ‚âÖ S ‚äó[R] A[f‚Åª¬π]`. -/
noncomputable def Localization.Away.tensorEquiv (R S : Type*) {A : Type*}
    [CommSemiring R] [CommSemiring S] [CommSemiring A]
    [Algebra R S] [Algebra R A] (f : A) :
    Away (1 ‚äó‚Çú[R] f : S ‚äó[R] A) ‚âÉ‚Çê[S] S ‚äó[R] Away f :=
  IsLocalization.tensorEquiv R S A _ _ (.powers f) (.powers (1 ‚äó‚Çú f)) (by simp)

@[simp] lemma Localization.Away.tensorEquiv_mk {R S : Type*} {A : Type*}
    [CommSemiring R] [CommSemiring S] [CommSemiring A]
    [Algebra R S] [Algebra R A] (f : A) (s : S) (a : A) (n : ‚Ñï) :
    tensorEquiv R S f (.mk (s ‚äó‚Çú a) ‚ü®1 ‚äó‚Çú (f ^ n), n, by simp‚ü©) = s ‚äó‚Çú .mk a ‚ü®f ^ n, n, rfl‚ü© := by
  simp_rw [tensorEquiv, IsLocalization.tensorEquiv, AlgEquiv.ofAlgHom_apply,
    IsLocalization.liftAlgHom_apply, mk_eq_mk', IsLocalization.lift_mk',
    Units.mul_inv_eq_iff_eq_mul, IsUnit.coe_liftRight]
  simp only [Algebra.algHom, AlgHom.toRingHom_eq_coe, RingHom.coe_coe,
    Algebra.TensorProduct.map_tmul, AlgHom.one_apply, AlgHom.coe_mk, ‚Üê mk_one_eq_algebraMap,
    ‚Üê mk_eq_mk', RingHom.toMonoidHom_eq_coe, AlgHom.toRingHom_toMonoidHom,
    MonoidHom.restrict_apply, MonoidHom.coe_coe, Algebra.TensorProduct.tmul_mul_tmul, mul_one,
    mk_mul]
  congr 1
  exact mk_eq_mk_iff.mpr <| r_iff_exists.mpr ‚ü®1, by simp [mul_comm]‚ü©

variable {R A : Type u} [CommRing R] [CommRing A] [Algebra R A]
  (ùíú : ‚Ñï ‚Üí Submodule R A) [GradedAlgebra ùíú]
  (S : Type u) [CommRing S] [Algebra R S]

namespace AlgebraicGeometry

open TensorProduct CategoryTheory Limits CommRingCat

noncomputable def Proj.toSpec : Proj ùíú ‚ü∂ Spec(R) :=
  Proj.toSpecZero ùíú ‚â´ Spec.map (ofHom (algebraMap R (ùíú 0)))

lemma baseChange_iSupEqTop :
    (HomogeneousIdeal.irrelevant fun n ‚Ü¶ (ùíú n).baseChange S).toIdeal ‚â§
    Ideal.span (Set.range fun f : (Proj.affineOpenCover ùíú).I‚ÇÄ ‚Ü¶ 1 ‚äó‚Çú[R] f.2) := by
  intro x hx
  classical
  rw [‚Üê DirectSum.sum_support_decompose (fun n ‚Ü¶ (ùíú n).baseChange S) x]
  refine sum_mem fun i hi ‚Ü¶ ?_
  have hi‚ÇÄ : i ‚â† 0 := fun hi‚ÇÄ ‚Ü¶ DFinsupp.mem_support_iff.mp hi (hi‚ÇÄ ‚ñ∏ by simpa using hx)
  generalize DirectSum.decompose (fun n ‚Ü¶ (ùíú n).baseChange S) x i = y
  obtain ‚ü®_, y, rfl‚ü© := y
  obtain ‚ü®s, rfl‚ü© := exists_finset y
  simp only [map_sum, LinearMap.baseChange_tmul, Submodule.subtype_apply]
  refine Ideal.sum_mem _ fun c hc ‚Ü¶ ?_
  rw [‚Üê mul_one c.1, ‚Üê one_mul (c.2: A), ‚Üê Algebra.TensorProduct.tmul_mul_tmul]
  refine Ideal.mul_mem_left _ _ <| Ideal.subset_span ‚ü®‚ü®‚ü®i, pos_of_ne_zero hi‚ÇÄ‚ü©, _‚ü©, rfl‚ü©

set_option maxHeartbeats 999999 in
-- I don't know why
noncomputable def awayBaseChange {i : ‚Ñï} {f : A} (hf : f ‚àà ùíú i) :
    HomogeneousLocalization.Away (fun n ‚Ü¶ (ùíú n).baseChange S) (1 ‚äó‚Çú[R] f) ‚âÉ‚Çê[S]
      S ‚äó[R] HomogeneousLocalization.Away ùíú f := by
  let f‚ÇÅ : HomogeneousLocalization.Away (fun n ‚Ü¶ (ùíú n).baseChange S) (1 ‚äó‚Çú[R] f) ‚Üí‚Çê[S]
      Localization.Away (1 ‚äó‚Çú f : S ‚äó[R] A) := Algebra.algHom _ _ _
  let f‚ÇÇ : Localization.Away (1 ‚äó‚Çú f : S ‚äó[R] A) ‚âÉ‚Çê[S]
      S ‚äó[R] Localization.Away (f : A) := Localization.Away.tensorEquiv _ _ _
  let f‚ÇÉ : S ‚äó[R] Localization.Away (f : A) ‚Üí‚Çó[S] S ‚äó[R] HomogeneousLocalization.Away ùíú f :=
    ((HomogeneousLocalization.Away.proj‚ÇÄ ùíú hf).restrictScalars R).baseChange S
  let forwards : HomogeneousLocalization.Away (fun n ‚Ü¶ (ùíú n).baseChange S) (1 ‚äó‚Çú[R] f) ‚Üí‚Çó[S]
      S ‚äó[R] HomogeneousLocalization.Away ùíú f :=
    f‚ÇÉ ‚àò‚Çó f‚ÇÇ.toLinearMap ‚àò‚Çó f‚ÇÅ.toLinearMap
  let backwards : S ‚äó[R] HomogeneousLocalization.Away ùíú f ‚Üí‚Çê[S]
      HomogeneousLocalization.Away (fun n ‚Ü¶ (ùíú n).baseChange S) (1 ‚äó‚Çú[R] f) :=
    AlgHom.liftBaseChange <| HomogeneousLocalization.Away.map‚Çê
      (Algebra.TensorProduct.includeRight (R := R) (A := S))
      (fun _ _ ‚Ü¶ Submodule.tmul_mem_baseChange_of_mem _) rfl
  refine
    have left : backwards.toLinearMap ‚àò‚Çó forwards = 1 := ?_
    have right : forwards ‚àò‚Çó backwards.toLinearMap = 1 := ?_
    .symm { __ := backwards, invFun := forwards, left_inv := ?_, right_inv := ?_ }
  ¬∑ ext x
    obtain ‚ü®n, a, rfl‚ü© := x.lof_surjective _ (Submodule.tmul_mem_baseChange_of_mem _ hf)
    obtain ‚ü®a, rfl‚ü© := Submodule.toBaseChange_surjective _ _ a
    simp only [smul_eq_mul, LinearMap.coe_comp, Function.comp_apply, AlgHom.toLinearMap_apply,
      Module.End.one_apply]
    induction a using TensorProduct.induction_on with
    | zero => simp
    | add a‚ÇÅ a‚ÇÇ ha‚ÇÅ ha‚ÇÇ => simp [ha‚ÇÅ, ha‚ÇÇ]
    | tmul s a =>
      simp only [forwards, f‚ÇÅ, f‚ÇÇ, f‚ÇÉ, backwards, Algebra.algHom]
      simp only [smul_eq_mul, LinearMap.coe_comp, Function.comp_apply, AlgHom.toLinearMap_apply,
        AlgHom.coe_mk, HomogeneousLocalization.algebraMap_apply, AlgEquiv.toLinearMap_apply]
      erw [HomogeneousLocalization.Away.val_lof]
      simp only [smul_eq_mul, Submodule.toBaseChange_tmul_coe, Algebra.TensorProduct.tmul_pow,
        one_pow, Localization.Away.tensorEquiv_mk, LinearMap.baseChange_tmul,
        LinearMap.coe_restrictScalars, HomogeneousLocalization.Away.proj‚ÇÄ_mk',
        AlgHom.liftBaseChange_tmul, HomogeneousLocalization.val_smul]
      erw [HomogeneousLocalization.Away.map‚Çê_lof]
      rw [HomogeneousLocalization.Away.val_lof]
      simp only [smul_eq_mul, Algebra.TensorProduct.includeRight_apply,
        Algebra.TensorProduct.tmul_pow, one_pow, Localization.smul_mk]
      congr 1
      rw [‚Üê tmul_eq_smul_one_tmul]
  ¬∑ ext x
    obtain ‚ü®n, a, rfl‚ü© := x.lof_surjective _ hf
    simp only [forwards, f‚ÇÅ, f‚ÇÇ, f‚ÇÉ, backwards, Algebra.algHom]
    simp only [AlgebraTensorModule.curry_apply, LinearMap.restrictScalars_comp, smul_eq_mul,
      curry_apply, LinearMap.coe_comp, LinearMap.coe_restrictScalars, Function.comp_apply,
      AlgHom.toLinearMap_apply, AlgHom.liftBaseChange_tmul, one_smul, AlgHom.coe_mk,
      HomogeneousLocalization.algebraMap_apply, AlgEquiv.toLinearMap_apply, Module.End.one_apply]
    erw [HomogeneousLocalization.Away.map‚Çê_lof]
    rw [HomogeneousLocalization.Away.val_lof]
    simp [HomogeneousLocalization.Away.proj‚ÇÄ_mk']
  ¬∑ exact fun x ‚Ü¶ congr($right x)
  ¬∑ exact fun x ‚Ü¶ congr($left x)

@[simps!] def _root_.GradedAlgebra.toTensor : ùíú ‚Üí·µç·µÉ fun n ‚Ü¶ (ùíú n).baseChange S where
  __ := Algebra.TensorProduct.includeRight
  map_mem' _ _ := Submodule.tmul_mem_baseChange_of_mem _

lemma _root_.GradedAlgebra.toTensor_admissible :
    (HomogeneousIdeal.irrelevant fun n ‚Ü¶ (ùíú n).baseChange S) ‚â§
    (HomogeneousIdeal.irrelevant ùíú).map (GradedAlgebra.toTensor ùíú S) := by
  refine (HomogeneousIdeal.irrelevant_le _).mpr fun i hi x hx ‚Ü¶ ?_
  obtain ‚ü®a, ha‚ü© := Submodule.toBaseChange_surjective _ _ ‚ü®x, hx‚ü©
  replace ha := congr(($ha).val); subst ha
  induction a with
  | zero => simp
  | add => simp [*, add_mem]
  | tmul s a =>
    simp only [Submodule.toBaseChange_tmul_coe]
    rw [tmul_eq_smul_one_tmul, ‚Üê algebraMap_smul (S ‚äó[R] A), smul_eq_mul]
    exact Ideal.mul_mem_left _ _ <| Ideal.mem_map_of_mem _ <|
      HomogeneousIdeal.mem_irrelevant_of_mem _ hi a.2

@[simp] lemma awayBaseChange_symm_tmul
    {i : ‚Ñï} {f : A} (hf : f ‚àà ùíú i) {s : S} {x : HomogeneousLocalization.Away ùíú f} :
    (awayBaseChange ùíú S hf).symm (s ‚äó‚Çú x) =
    s ‚Ä¢ .map (GradedAlgebra.toTensor ùíú S) rfl x := by
  obtain ‚ü®n, a, rfl‚ü© := x.lof_surjective _ hf
  rw [AlgEquiv.symm_apply_eq, HomogeneousLocalization.Away.map_lof, map_smul]
  simp only [smul_eq_mul, awayBaseChange, AlgHom.toRingHom_eq_coe, RingHom.toMonoidHom_eq_coe,
    AlgHom.toRingHom_toMonoidHom, OneHom.toFun_eq_coe, MonoidHom.toOneHom_coe, MonoidHom.coe_coe,
    Algebra.algHom, LinearMap.coe_comp, AlgEquiv.symm_mk, GradedAlgebra.toTensor_toFun,
    AlgEquiv.coe_mk, Equiv.coe_fn_mk, Function.comp_apply, AlgHom.toLinearMap_apply, AlgHom.coe_mk,
    HomogeneousLocalization.algebraMap_apply, AlgEquiv.toLinearMap_apply]
  conv => enter [2,2,2,2]; exact HomogeneousLocalization.Away.val_lof _ _ _ _
  simp [HomogeneousLocalization.Away.lof, HomogeneousLocalization.lof,
    HomogeneousLocalization.Away.proj‚ÇÄ_mk, HomogeneousLocalization.Away.mk,
    ‚Üê tmul_eq_smul_one_tmul]

@[simp] lemma awayBaseChange_lof {i : ‚Ñï} {f : A} (hf : f ‚àà ùíú i) {s : S} {n : ‚Ñï} {a : ùíú (n ‚Ä¢ i)} :
    awayBaseChange ùíú S hf (.lof (fun n ‚Ü¶ (ùíú n).baseChange S)
      (Submodule.tmul_mem_baseChange_of_mem _ hf) n (Submodule.toBaseChange _ _ (s ‚äó‚Çú a))) =
    s ‚äó‚Çú .lof _ hf n a := by
  rw [‚Üê AlgEquiv.eq_symm_apply, awayBaseChange_symm_tmul,
    HomogeneousLocalization.Away.map_lof, tmul_eq_smul_one_tmul s, map_smul, map_smul]
  rfl

noncomputable def Proj.baseChangeIsoComponent {i : ‚Ñï} {f : A} (hf : f ‚àà ùíú i) :
    Spec(HomogeneousLocalization.Away (fun n ‚Ü¶ (ùíú n).baseChange S) (1 ‚äó‚Çú[R] f)) ‚âÖ
    pullback (Spec.map (ofHom (algebraMap R S)))
      (Spec.map (ofHom (algebraMap R (HomogeneousLocalization.Away ùíú f)))) :=
  Scheme.Spec.mapIso (awayBaseChange ùíú S hf).toCommRingCatIso.op.symm ‚â™‚â´
  (pullbackSpecIso _ _ _).symm

@[reassoc (attr := simp)] lemma Proj.baseChangeIsoComponent_hom_comp_pullback_fst
    {i : ‚Ñï} {f : A} (hf : f ‚àà ùíú i) :
    (Proj.baseChangeIsoComponent ùíú S hf).hom ‚â´ pullback.fst _ _ =
    Spec.map (ofHom (algebraMap S _)) := by
  simp only [HomogeneousLocalization.algebraMap_eq', ofHom_comp, baseChangeIsoComponent,
    Scheme.Spec_obj, AlgEquiv.toRingEquiv_eq_coe, Functor.mapIso_symm, Iso.trans_hom, Iso.symm_hom,
    Functor.mapIso_inv, Iso.op_inv, RingEquiv.toCommRingCatIso_inv, Scheme.Spec_map,
    Quiver.Hom.unop_op, Category.assoc]
  conv => enter [1,2]; exact pullbackSpecIso_inv_fst ..
  simp only [‚Üê Spec.map_comp, ‚Üê ofHom_comp]
  congr 2; ext s
  simp [‚Üê AlgEquiv.symm_toRingEquiv, IsScalarTower.algebraMap_apply S (S ‚äó[R] A) (Localization _),
    ‚Üê Localization.mk_one_eq_algebraMap, tmul_eq_smul_one_tmul s, ‚Üê Localization.smul_mk,
    ‚Üê Algebra.TensorProduct.one_def, Localization.mk_one]

@[reassoc (attr := simp)] lemma Proj.baseChangeIsoComponent_hom_comp_pullback_snd
    {i : ‚Ñï} {f : A} (hf : f ‚àà ùíú i) :
    (Proj.baseChangeIsoComponent ùíú S hf).hom ‚â´ pullback.snd _ _ =
    Spec.map (ofHom (HomogeneousLocalization.Away.map (GradedAlgebra.toTensor ..) rfl)) := by
  simp only [HomogeneousLocalization.algebraMap_eq', ofHom_comp, baseChangeIsoComponent,
    Scheme.Spec_obj, AlgEquiv.toRingEquiv_eq_coe, Functor.mapIso_symm, Iso.trans_hom, Iso.symm_hom,
    Functor.mapIso_inv, Iso.op_inv, RingEquiv.toCommRingCatIso_inv, Scheme.Spec_map,
    Quiver.Hom.unop_op, Category.assoc, GradedAlgebra.toTensor_toFun]
  conv => enter [1,2]; exact pullbackSpecIso_inv_snd ..
  rw [‚Üê Spec.map_comp, ‚Üê ofHom_comp]
  congr 2; ext x
  simp [‚Üê AlgEquiv.symm_toRingEquiv]

@[reassoc] lemma Proj.map_toSpec {R R‚ÇÅ R‚ÇÇ A B : Type u}
    [CommRing R] [CommRing R‚ÇÅ] [CommRing R‚ÇÇ] [CommRing A] [CommRing B]
    [Algebra R R‚ÇÅ] [Algebra R R‚ÇÇ] [Algebra R A] [Algebra R B]
    [Algebra R‚ÇÅ A] [IsScalarTower R R‚ÇÅ A] [Algebra R‚ÇÇ B] [IsScalarTower R R‚ÇÇ B]
    (ùíú : ‚Ñï ‚Üí Submodule R‚ÇÅ A) [GradedAlgebra ùíú]
    (‚Ñ¨ : ‚Ñï ‚Üí Submodule R‚ÇÇ B) [GradedAlgebra ‚Ñ¨]
    (f : ùíú ‚Üí·µç·µÉ ‚Ñ¨) (hf) (hfr : ‚àÄ r, f (algebraMap R A r) = algebraMap R B r) :
    Proj.map f hf ‚â´ Proj.toSpec ùíú ‚â´ Spec.map (ofHom (algebraMap R R‚ÇÅ)) =
    Proj.toSpec ‚Ñ¨ ‚â´ Spec.map (ofHom (algebraMap R R‚ÇÇ)) := by
  simp only [toSpec, Category.assoc, ‚Üê Spec.map_comp, ‚Üê ofHom_comp, map_comp_toSpecZero_assoc]
  congr 3; ext; simp [‚Üê IsScalarTower.algebraMap_apply, hfr]

@[reassoc (attr := simp)] lemma Proj.map_toTensor_toSpec :
    Proj.map _ (GradedAlgebra.toTensor_admissible ùíú S) ‚â´ Proj.toSpec ùíú =
    Proj.toSpec _ ‚â´ Spec.map (ofHom (algebraMap R S)) := by
  simpa using Proj.map_toSpec (R := R) _ _ _ (GradedAlgebra.toTensor_admissible ùíú S) fun r ‚Ü¶ by
    simp [Algebra.TensorProduct.one_def, Algebra.algebraMap_eq_smul_one r, smul_tmul']

noncomputable def ofProjTensor :
    Proj (fun n ‚Ü¶ (ùíú n).baseChange S) ‚ü∂
    pullback (Spec.map (ofHom (algebraMap R S))) (Proj.toSpec ùíú) :=
  pullback.lift (Proj.toSpec _) (Proj.map _ <| GradedAlgebra.toTensor_admissible _ _) <| by simp

@[reassoc (attr := simp)] lemma Proj.awayŒπ_comp_toSpec
    {i : ‚Ñï} (hi : 0 < i) {s : A} (hs : s ‚àà ùíú i) :
    Proj.awayŒπ ùíú s hs hi ‚â´ Proj.toSpec ùíú = Spec.map (ofHom (algebraMap _ _)) := by
  simp [toSpec, awayŒπ_toSpecZero_assoc]

/--
The following square commutes:
```
Proj(S ‚äó[R] ùíú) ---------‚ü∂ Spec(S) √ó[Spec(R)] Proj(ùíú)
    ^           ofProjTensor             ^
    |                                    |
    | awayŒπ                              | ùüô √ó awayŒπ
    |                                    |
    |           baseChangeIsoComponent   |
Spec((S‚äó[R]A)[(1‚äós)‚Åª¬π]) ‚ü∂ Spec(S) √ó[Spec(R)] Spec(A[s‚Åª¬π])
```
-/
@[simp] lemma awayŒπ_comp_ofProjTensor {i : ‚Ñï} (hi : 0 < i) {s : A} (hs : s ‚àà ùíú i) :
    Proj.awayŒπ (fun n ‚Ü¶ (ùíú n).baseChange S) (1 ‚äó‚Çú s) (Submodule.tmul_mem_baseChange_of_mem _ hs)
      hi ‚â´ ofProjTensor ùíú S =
    (Proj.baseChangeIsoComponent ùíú S hs).hom ‚â´
      pullback.map _ _ _ _ (ùüô _) (Proj.awayŒπ _ s hs hi) (ùüô _) (by simp) (by simp) :=
  pullback.hom_ext (by simp [- HomogeneousLocalization.algebraMap_eq', ofProjTensor]) <| by
  simpa [- HomogeneousLocalization.algebraMap_eq', ofProjTensor] using
    Proj.awayŒπ_comp_map _ (GradedAlgebra.toTensor_admissible ùíú S) hi s hs

namespace Scheme

@[simp] lemma image_comp {X Y Z : Scheme.{u}} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z}
    [IsOpenImmersion f] [IsOpenImmersion g] (U : X.Opens) :
    (f ‚â´ g) ''·µÅ U = g ''·µÅ f ''·µÅ U :=
  TopologicalSpace.Opens.ext <| Set.image_comp g.base f.base (U : Set X)

lemma image_id' {X : Scheme.{u}} {f : X ‚ü∂ X} [IsOpenImmersion f] (hf : f = ùüô X) {U : X.Opens} :
    f ''·µÅ U = U := by
  subst hf; exact TopologicalSpace.Opens.ext <| Set.image_id _

@[simp] lemma image_inv {X Y : Scheme.{u}} {f : X ‚âÖ Y} (V : Y.Opens) :
    f.inv ''·µÅ V = f.hom ‚Åª¬π·µÅ V := by
  rw [‚Üê f.hom.preimage_image_eq (f.inv ''·µÅ V), ‚Üê image_comp, image_id' (by simp)]

@[simp] lemma image_inv' {X Y : Scheme.{u}} {f : X ‚ü∂ Y} [IsIso f] (V : Y.Opens) :
    (inv f) ''·µÅ V = f ‚Åª¬π·µÅ V :=
  image_inv (f := asIso f) V

@[simp] lemma image_preimage {X Y : Scheme.{u}} {f : X ‚ü∂ Y} [IsIso f] {V : Y.Opens} :
    f ''·µÅ (f ‚Åª¬π·µÅ V) = V :=
  TopologicalSpace.Opens.ext <| Set.image_preimage_eq _
    (ConcreteCategory.bijective_of_isIso f.base).surjective

lemma image_eq_iff_eq_preimage {X Y : Scheme.{u}} {f : X ‚ü∂ Y} [IsIso f]
    {U : X.Opens} {V : Y.Opens} :
    f ''·µÅ U = V ‚Üî U = f ‚Åª¬π·µÅ V :=
  ‚ü®(¬∑ ‚ñ∏ by simp), (¬∑ ‚ñ∏ by simp)‚ü©

end Scheme

/-- To check if `f : X ‚ü∂ Y` is an isomorphism, one can supply an open cover of `X` and an open
cover of `Y` (indexed by the same set `S`), and then maps `f_i : U_i ‚ü∂ V_i` for `i : S` that are
iso such that the squares commute. -/
theorem isIso_of_cover {X Y : Scheme.{v}} (f : X ‚ü∂ Y)
    (U : X.OpenCover) (V : Y.OpenCover)
    {Œπ : Type*} (iU : Œπ ‚Üí U.I‚ÇÄ) (hu : iU.Surjective) (iV : Œπ ‚Üí V.I‚ÇÄ) (hv : iV.Surjective)
    (œÜ : ‚àÄ i : Œπ, U.X (iU i) ‚ü∂ V.X (iV i)) [‚àÄ i, IsIso (œÜ i)]
    (hfœÜ : ‚àÄ i : Œπ, U.f (iU i) ‚â´ f = œÜ i ‚â´ V.f (iV i))
    (preimage : ‚àÄ i : Œπ, f ‚Åª¬π·µÅ (V.f (iV i)).opensRange = (U.f (iU i)).opensRange) :
    IsIso f :=
  let U' : X.OpenCover :=
  { I‚ÇÄ := Œπ
    X i := U.X (iU i)
    f i := U.f (iU i)
    idx x := (hu (U.idx x)).choose
    covers x := by rw [(hu (U.idx x)).choose_spec]; exact U.covers x }
  let V' : Y.OpenCover :=
  { I‚ÇÄ := Œπ
    X i := V.X (iV i)
    f i := V.f (iV i)
    idx y := (hv (V.idx y)).choose
    covers y := by rw [(hv (V.idx y)).choose_spec]; exact V.covers y }
  let inv : Y ‚ü∂ X := V'.glueMorphisms (fun i : Œπ ‚Ü¶ inv (œÜ i) ‚â´ U'.f i) fun i‚ÇÅ i‚ÇÇ : Œπ ‚Ü¶ by
    let p : pullback (V'.f i‚ÇÅ) (V'.f i‚ÇÇ) ‚ü∂ pullback (U'.f i‚ÇÅ) (U'.f i‚ÇÇ) :=
      IsOpenImmersion.lift (pullback.fst _ _) (pullback.fst _ _ ‚â´ inv (œÜ i‚ÇÅ)) <| by
        rw [‚Üê Scheme.Hom.coe_opensRange, ‚Üê Scheme.Hom.coe_opensRange, SetLike.coe_subset_coe,
          IsOpenImmersion.opensRange_pullback_fst_of_right, Scheme.Hom.opensRange_comp,
          IsOpenImmersion.opensRange_pullback_fst_of_right, Scheme.image_inv',
          ‚Üê Scheme.preimage_comp, ‚Üê hfœÜ, Scheme.preimage_comp, preimage]
    have hp‚ÇÅ : p ‚â´ pullback.fst _ _ = pullback.fst _ _ ‚â´ inv (œÜ i‚ÇÅ) :=
      IsOpenImmersion.lift_fac _ _ _
    have hp‚ÇÇ : p ‚â´ pullback.snd _ _ = pullback.snd _ _ ‚â´ inv (œÜ i‚ÇÇ) := by
      rw [IsIso.eq_comp_inv]
      refine (cancel_mono (V'.f i‚ÇÇ)).mp ?_
      simp_rw [Category.assoc]
      rw [‚Üê hfœÜ, ‚Üê pullback.condition_assoc, reassoc_of% hp‚ÇÅ, hfœÜ, IsIso.inv_hom_id_assoc,
        pullback.condition]
    dsimp only
    rw [‚Üê reassoc_of% hp‚ÇÅ, pullback.condition, reassoc_of% hp‚ÇÇ]
  have comp_inv : f ‚â´ inv = ùüô X := U'.hom_ext _ _ fun i ‚Ü¶ by
    unfold inv
    rw [reassoc_of% hfœÜ, V'.Œπ_glueMorphisms, IsIso.hom_inv_id_assoc, Category.comp_id]
  have inv_comp : inv ‚â´ f = ùüô Y := V'.hom_ext _ _ fun i ‚Ü¶ by
    unfold inv
    rw [V'.Œπ_glueMorphisms_assoc, Category.assoc, hfœÜ, IsIso.inv_hom_id_assoc, Category.comp_id]
  ‚ü®inv, comp_inv, inv_comp‚ü©

noncomputable def Proj.openCoverBaseChange :
    (Proj fun n ‚Ü¶ (ùíú n).baseChange S).AffineOpenCover :=
  Proj.mapAffineOpenCover _ <| GradedAlgebra.toTensor_admissible ùíú S

noncomputable def Proj.openCoverPullback :
    (pullback (Spec.map (ofHom (algebraMap R S))) (Proj.toSpec ùíú)).OpenCover :=
  (Scheme.Pullback.openCoverOfRight (Proj.affineOpenCover ùíú).openCover
      (Spec.map <| ofHom <| algebraMap R S) (Proj.toSpec ùíú)).copy
    (Proj.affineOpenCover ùíú).I‚ÇÄ
    (fun f ‚Ü¶ pullback (Spec.map (ofHom (algebraMap R S)))
      (Spec.map (ofHom (algebraMap R (HomogeneousLocalization.Away ùíú f.2)))))
    (fun f ‚Ü¶ pullback.map _ _ _ _ (ùüô _) (Proj.awayŒπ ùíú f.2 f.2.2 f.1.2) (ùüô _) (by simp) (by simp))
    (Equiv.refl _) (fun _ ‚Ü¶ pullback.congrHom rfl (by simp [affineOpenCover, openCoverOfISupEqTop]))
    fun f ‚Ü¶ pullback.hom_ext (by simp) (by simp [Proj.affineOpenCover, Proj.openCoverOfISupEqTop])

@[simp] lemma Proj.opensRange_openCoverPullback {f} :
    ((Proj.openCoverPullback ùíú S).f f).opensRange =
    pullback.snd (Spec.map (ofHom (algebraMap R S))) (toSpec ùíú) ‚Åª¬π·µÅ basicOpen _ f.2 :=
  TopologicalSpace.Opens.ext <| by
    simp [openCoverPullback, Scheme.Pullback.range_map, ‚Üê Proj.opensRange_awayŒπ _ _ f.2.2]

instance : IsIso (ofProjTensor ùíú S) :=
  isIso_of_cover _ (Proj.openCoverBaseChange ùíú S).openCover
    (Proj.openCoverPullback ùíú S)
    id Function.surjective_id id Function.surjective_id
    (fun f ‚Ü¶ (Proj.baseChangeIsoComponent ùíú S f.2.2).hom)
    (fun f ‚Ü¶ by simp [Proj.openCoverBaseChange, Proj.openCoverPullback])
    fun f ‚Ü¶ by simp [‚Üê Scheme.preimage_comp, - TopologicalSpace.Opens.map_comp_obj, ofProjTensor,
      Proj.openCoverBaseChange, Proj.opensRange_awayŒπ]

-- https://math.arizona.edu/~cais/CourseNotes/AlgGeom04/notes216.pdf
noncomputable def projTensorProduct : Proj (fun n ‚Ü¶ (ùíú n).baseChange S) ‚âÖ
    pullback (Spec.map (ofHom (algebraMap R S))) (Proj.toSpec ùíú) :=
  asIso <| ofProjTensor ùíú S

@[simp] lemma projTensorProduct_hom_comp_pullback_fst :
    (projTensorProduct ùíú S).hom ‚â´ pullback.fst _ _ = Proj.toSpec _ := by
  simp [projTensorProduct, ofProjTensor]

@[simp] lemma projTensorProduct_hom_comp_pullback_snd :
    (projTensorProduct ùíú S).hom ‚â´ pullback.snd _ _ =
    Proj.map _ (GradedAlgebra.toTensor_admissible ùíú S) := by
  simp [projTensorProduct, ofProjTensor]

@[simp] lemma awayŒπ_comp_projTensorProduct {i : ‚Ñï} (hi : 0 < i) {s : A} (hs : s ‚àà ùíú i) :
    Proj.awayŒπ (fun n ‚Ü¶ (ùíú n).baseChange S) (1 ‚äó‚Çú s) (Submodule.tmul_mem_baseChange_of_mem _ hs)
      hi ‚â´ (projTensorProduct ùíú S).hom =
    (Proj.baseChangeIsoComponent ùíú S hs).hom ‚â´
      pullback.map _ _ _ _ (ùüô _) (Proj.awayŒπ _ s hs hi) (ùüô _) (by simp) (by simp) :=
  awayŒπ_comp_ofProjTensor _ _ _ _

@[simp] lemma projTensorProduct_image_basicOpen {s : A} :
    (projTensorProduct ùíú S).hom ''·µÅ (Proj.basicOpen (fun n ‚Ü¶ (ùíú n).baseChange S) (1 ‚äó‚Çú s)) =
    pullback.snd (Spec.map (ofHom (algebraMap R S))) (Proj.toSpec ùíú) ‚Åª¬π·µÅ Proj.basicOpen ùíú s := by
  rw [Scheme.image_eq_iff_eq_preimage, ‚Üê Scheme.preimage_comp,
    projTensorProduct_hom_comp_pullback_snd, Proj.map_preimage_basicOpen,
    GradedAlgebra.toTensor_toFun]

end AlgebraicGeometry
